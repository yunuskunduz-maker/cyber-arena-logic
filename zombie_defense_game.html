<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>CYBER-ARENA: TOWER DEFENSE 2026 - FINAL</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .panel { position: absolute; background: rgba(0, 0, 0, 0.85); border: 2px solid #00ff00; color: #00ff00; padding: 12px; border-radius: 5px; pointer-events: all; font-weight: bold; }
        #top-left { top: 20px; left: 20px; }
        #top-center { top: 20px; left: 50%; transform: translateX(-50%); width: 340px; text-align: center; border-color: #ff00ff; color: #ff00ff; }
        #bottom-right { bottom: 20px; right: 20px; text-align: right; }
        #center-msg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.9); color: #fff; z-index: 1000; cursor: pointer; pointer-events: all; }
        #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; background: rgba(100, 0, 0, 0.8); color: #fff; z-index: 2000; pointer-events: all; }
        #shop { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 480px; display: none; z-index: 1001; background: #111; border: 4px solid #00ff00; max-height: 85vh; overflow-y: auto; color: #fff; }
        .shop-item { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; padding: 10px; background: #222; border: 1px solid #00ff00; }
        button { background: #00ff00; color: #000; border: none; padding: 10px 15px; font-weight: bold; cursor: pointer; font-family: 'Orbitron'; transition: 0.3s; }
        button:hover { background: #fff; box-shadow: 0 0 15px #00ff00; }
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 16px; height: 16px; border: 2px solid #00ff00; border-radius: 50%; pointer-events: none; }
        #sniper-scope { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 35%, black 75%); display: none; z-index: 50; pointer-events: none; border: 200px solid black; box-sizing: border-box; }
        #scope-crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        #scope-crosshair::before { content: ""; position: absolute; width: 2px; height: 100%; background: rgba(0, 255, 0, 0.4); }
        #scope-crosshair::after { content: ""; position: absolute; width: 100%; height: 2px; background: rgba(0, 255, 0, 0.4); }
        .bar-container { width: 100%; height: 10px; background: #333; margin-top: 5px; border: 1px solid #555; }
        .bar-fill { height: 100%; transition: width 0.3s; }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div id="crosshair"></div>
<div id="sniper-scope"><div id="scope-crosshair"></div></div>

<div id="hud">
    <div id="top-left" class="panel">
        <div id="cycle-text">DÖNGÜ: GÜNDÜZ</div>
        <div>DALGA: <span id="wave-count">1</span></div>
        <div>OYUNCU HP: <span id="hp-val">100</span> | BOMBA: <span id="grenade-count">3</span></div>
        <div class="bar-container"><div id="hp-fill" class="bar-fill" style="width: 100%; background: #00ff00;"></div></div>
    </div>
    <div id="top-center" class="panel">
        <div style="font-size: 1.1em; letter-spacing: 2px;">ANA KULE <span id="shield-status" style="font-size: 0.7em; color: #00ffff;"></span></div>
        <div>KULE HP: <span id="tower-hp-val">1000</span> / 1000</div>
        <div class="bar-container"><div id="tower-hp-fill" class="bar-fill" style="width: 100%; background: #ff00ff;"></div></div>
        <div style="font-size: 0.7em; margin-top: 5px; color: #aaa;">TAMİR: 'E' (500$) | <span id="regen-status" style="color:#0f0"></span></div>
    </div>
    <div id="bottom-right" class="panel">
        <div id="weapon-name" style="color: #00ff00;">PULSE PISTOL</div>
        <div id="ammo-display" style="font-size: 30px;">30 / 120</div>
        <div>KREDİ: <span id="credits">0</span> $</div>
    </div>
    <div id="center-msg">
        <h1 style="font-size: 3.5em; color: #00ff00; text-shadow: 0 0 20px #00ff00;">CYBER TOWER DEFENSE</h1>
        <p style="font-size: 1.2em;">BAŞLATMAK İÇİN TIKLA</p>
    </div>
    <div id="death-screen">
        <h1 style="font-size: 3em; color: #ff0000;">ÖLDÜNÜZ!</h1>
        <button onclick="game.player.respawn()" style="padding: 20px 40px; font-size: 1.5em; margin-top: 20px;">YENİDEN DOĞ</button>
    </div>
    <div id="shop" class="panel">
        <h2 style="text-align: center; color: #00ff00;">MİLLİ SAVUNMA MARKETİ</h2>
        <div id="shop-list"></div>
        <button style="width: 100%; margin-top: 10px; background: #ff4400; color: #fff;" onclick="game.toggleShop(false)">KAPAT</button>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    class Game {
        constructor() {
            this.initScene();
            this.treeObstacles = [];
            this.enemies = []; this.allies = []; this.grenades = []; this.walls = [];
            this.player = new Player(this);
            this.wave = 1; this.credits = 5000; this.isPaused = true;
            this.isNight = false;
            this.towerHP = 1000;
            this.hasShield = false;
            this.hasRegen = false;
            this.setupEvents();
            this.initShop();
            this.addTrees(40);
            this.animate();
        }

        playSynthSound(type) {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain); gain.connect(ctx.destination);
            
            if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(880, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth'; 
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                osc.start(); osc.stop(ctx.currentTime + 0.5);
            } else if (type === 'repair') {
                osc.type = 'triangle'; 
                osc.frequency.setValueAtTime(440, ctx.currentTime);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
                osc.start(); osc.stop(ctx.currentTime + 0.3);
            }
        }

        initScene() {
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x87ceeb);
            this.scene.fog = new THREE.FogExp2(0x87ceeb, 0.012);
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.scene.add(this.camera);
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(this.renderer.domElement);
            this.ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            this.scene.add(this.ambientLight);
            this.sunLight = new THREE.DirectionalLight(0xffffff, 0.6);
            this.sunLight.position.set(5, 20, 5);
            this.scene.add(this.sunLight);
            this.flashlight = new THREE.SpotLight(0xffffff, 0);
            this.flashlight.distance = 50;
            this.camera.add(this.flashlight);
            this.flashlight.position.set(0, 0, 1);
            this.flashlight.target = new THREE.Object3D();
            this.camera.add(this.flashlight.target);
            this.flashlight.target.position.set(0, 0, -5);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x2d3a22 }));
            floor.rotation.x = -Math.PI / 2;
            this.scene.add(floor);
            const towerGeo = new THREE.CylinderGeometry(3, 4, 15, 8);
            this.towerMat = new THREE.MeshPhongMaterial({ color: 0x222222, emissive: 0xff00ff, emissiveIntensity: 0.2 });
            this.tower = new THREE.Mesh(towerGeo, this.towerMat);
            this.tower.position.set(0, 7.5, 0);
            this.scene.add(this.tower);
            for(let i=0; i<4; i++){
                const wall = new THREE.Mesh(new THREE.BoxGeometry(10, 3, 2), new THREE.MeshPhongMaterial({color: 0x555555}));
                const angle = (i * Math.PI) / 2;
                wall.position.set(Math.cos(angle)*12, 1.5, Math.sin(angle)*12);
                wall.rotation.y = -angle;
                this.scene.add(wall);
            }
        }

        addTrees(count) {
            for(let i=0; i<count; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                if(Math.abs(x) > 20 || Math.abs(z) > 20) { 
                    const tree = new THREE.Group();
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 3), new THREE.MeshPhongMaterial({color: 0x3d2b1f}));
                    trunk.position.y = 1.5;
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(2.5, 6, 8), new THREE.MeshPhongMaterial({color: 0x0a1a0a}));
                    leaves.position.y = 5;
                    tree.add(trunk, leaves);
                    tree.position.set(x, 0, z);
                    this.scene.add(tree);
                    this.treeObstacles.push({ x: x, z: z, radius: 1.0 }); 
                }
            }
        }

        updateCycle() {
            const cycleText = document.getElementById('cycle-text');
            const dayLength = 10000;
            if (this.enemies.length === 0 && this.isNight) {
                this.isNight = false; this.wave++; this.ambientLight.intensity = 0.8;
                this.flashlight.intensity = 0; this.scene.background.setHex(0x87ceeb);
                this.scene.fog.color.setHex(0x87ceeb); cycleText.innerText = "DÖNGÜ: GÜNDÜZ"; cycleText.style.color = "#00ff00";
            } else if (!this.isNight && this.enemies.length === 0) {
                if(!this.dayTimer) this.dayTimer = Date.now();
                let elapsed = Date.now() - this.dayTimer;
                let remaining = Math.ceil((dayLength - elapsed) / 1000);
                if (remaining <= 3 && remaining > 0) { cycleText.innerText = `ZOMBİLER GELİYOR: ${remaining}`; cycleText.style.color = "#ffa500"; }
                else { cycleText.innerText = `SALDIRIYA SON: ${remaining}s`; cycleText.style.color = "#00ff00"; }
                if (elapsed > dayLength) {
                    this.isNight = true; this.dayTimer = null; this.ambientLight.intensity = 0.25;
                    this.flashlight.intensity = 1.5; this.scene.background.setHex(0x020202);
                    this.scene.fog.color.setHex(0x020202); cycleText.innerText = "GECE (KULEYİ KORU!)";
                    this.flashlight.visible = true;
                    cycleText.style.color = "#ff0000"; this.spawnWave();
                }
            }
        }

        setupEvents() {
            const startBtn = document.getElementById('center-msg');
            startBtn.addEventListener('click', () => document.body.requestPointerLock());
            document.addEventListener('pointerlockchange', () => {
                this.isPaused = document.pointerLockElement !== document.body;
                if (!this.player.isDead) startBtn.style.display = this.isPaused ? 'flex' : 'none';
            });
            document.addEventListener('keydown', (e) => {
                if (this.isPaused || this.player.isDead) return;
                if (e.code === 'KeyM') this.toggleShop(true);
                if (e.code === 'KeyR') this.player.weapon.reload();
                if (e.code === 'KeyG') this.player.throwGrenade();
                if (e.code === 'Space') this.player.jump();
                if (e.code === 'KeyE') {
                    if (this.credits >= 500 && this.towerHP < 1000) {
                        this.credits -= 500; this.towerHP = Math.min(1000, this.towerHP + 250);
                        this.playSynthSound('repair'); this.player.updateUI();
                        this.updateTowerVisual();
                    }
                }
            });
        }

        initShop() {
            const items = [
                {id:'grenades', n:'+3 EL BOMBASI', p:1000},
                {id:'sniper', n:'AWM SNIPER', p:2000}, 
                {id:'wall', n:'SAVUNMA DUVARI', p:1000}, 
                {id:'guard', n:'KULE MUHAFIZI', p:6000}, 
                {id:'regen', n:'OTOMATİK TAMİR MODÜLÜ', p:4000}, 
                {id:'smg', n:'KARAKURT SMG', p:1500}, 
                {id:'shotgun', n:'EJDER POMPALI', p:2500},
                {id:'shield', n:'KALKAN SİSTEMİ', p:4000},
                {id:'turret', n:'SAVUNMA TARETİ', p:3000},
                {id:'soldier_p', n:'ASAYİŞ ASKERİ (tabanca)', p:4500},
                {id:'soldier_s', n:'KOMANDO (smg)', p:8500},
                {id:'soldier_sn', n:'KESKİN NİŞANCI (sniper)', p:12000},
                {id:'soldier_sh', n:'AĞIR MUHAFIZ (pompalı)', p:15000},
                {id:'auto_sniper', n:'GÖKTÜRK OTO-SNIPER', p:15000} // FINAL SILAH EKLEMESI
            ];
            const list = document.getElementById('shop-list');
            list.innerHTML = ""; 
            items.forEach(i => { list.innerHTML += `<div class="shop-item"><span>${i.n}<br><small>${i.p}$</small></span><button onclick="game.buy('${i.id}', ${i.p})">AL</button></div>`; });
        }

        buy(id, price) {
            if (this.credits >= price) {
                if (id === 'grenades') { 
                    this.player.grenades += 3; this.credits -= price;
                } else if (id === 'sniper') { 
                    this.player.weapon.upgrade('sniper'); this.credits -= price;
                } else if (id === 'auto_sniper') { // OTO SNIPER SATIN ALMA
                    this.player.weapon.upgrade('auto_sniper'); this.credits -= price;
                } else if (id === 'wall') { 
                    const pPos = this.player.camera.position.clone();
                    const pDir = new THREE.Vector3(0,0,-1).applyQuaternion(this.player.camera.quaternion);
                    const spawnPos = pPos.add(pDir.multiplyScalar(4)); spawnPos.y = 1.5;
                    this.walls.push(new Wall(this, spawnPos)); this.credits -= price;
                } else if (id === 'guard') { 
                    this.allies.push(new AllySoldier(this, new THREE.Vector3(0, 15.6, 0), 'sniper')); this.credits -= price;
                } else if (id === 'regen') { 
                    this.hasRegen = true; document.getElementById('regen-status').innerText = "[AUTO-REPAIR]"; this.credits -= price;
                } else if (id === 'shield') {
                    if (this.hasShield) return; this.hasShield = true;
                    document.getElementById('shield-status').innerText = "[KALKAN AKTİF]";
                    this.updateTowerVisual(); this.credits -= price;
                } else if (id.startsWith('soldier_')) {
                    const type = id.split('_')[1];
                    const pPos = this.player.camera.position.clone();
                    const pDir = new THREE.Vector3(0,0,-1).applyQuaternion(this.player.camera.quaternion);
                    const spawnPos = pPos.add(pDir.multiplyScalar(4)); spawnPos.y = 0.5;
                    this.allies.push(new AllySoldier(this, spawnPos, type === 'p' ? 'pistol' : type === 's' ? 'smg' : type === 'sn' ? 'sniper' : 'shotgun'));
                    this.credits -= price;
                } else if (id === 'smg') {
                    this.player.weapon.upgrade('smg'); this.credits -= price;
                } else if (id === 'shotgun') {
                    this.player.weapon.upgrade('shotgun'); this.credits -= price;
                } else if (id === 'turret') {
                    const pPos = this.player.camera.position.clone();
                    const pDir = new THREE.Vector3(0,0,-1).applyQuaternion(this.player.camera.quaternion);
                    const spawnPos = pPos.add(pDir.multiplyScalar(4)); spawnPos.y = 0.5;
                    this.allies.push(new Turret(this, spawnPos)); this.credits -= price;
                }
                this.player.updateUI(); this.toggleShop(false);
            }
        }

        toggleShop(show) { document.getElementById('shop').style.display = show ? 'block' : 'none'; if (show) document.exitPointerLock(); else document.body.requestPointerLock(); }
        
        spawnWave() { 
            // FINAL DUZENLEME: Maksimum zombi sayısı %30 artırılarak 16'ya çıkarıldı.
            let zombieCount = Math.min(16, 3 + Math.floor(this.wave / 2)); 
            for (let i = 0; i < zombieCount; i++) this.enemies.push(new Zombie(this)); 
            document.getElementById('wave-count').innerText = this.wave; 
        }
        
        updateTowerVisual() {
            if (this.towerHP >= 300) {
                if (this.hasShield) { this.towerMat.emissive.setHex(0x00ffff); this.towerMat.emissiveIntensity = 0.5; }
                else { this.towerMat.emissive.setHex(0xff00ff); this.towerMat.emissiveIntensity = 0.2; }
            } else {
                this.towerMat.emissive.setHex(0xff0000); this.towerMat.emissiveIntensity = Math.sin(Date.now() * 0.01) + 1.5;
            }
        }

        towerTakeDamage(amt) {
            if (this.hasShield) amt *= 0.6;
            this.towerHP -= amt;
            document.getElementById('tower-hp-val').innerText = Math.round(this.towerHP);
            document.getElementById('tower-hp-fill').style.width = (this.towerHP / 10) + "%";
            this.updateTowerVisual();
            if (this.towerHP <= 0) { alert("KULE YIKILDI! OYUN BİTTİ."); location.reload(); }
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            if (this.isPaused) return;
            if (this.hasRegen && this.towerHP < 1000) {
                this.towerHP = Math.min(1000, this.towerHP + 0.05);
                document.getElementById('tower-hp-val').innerText = Math.round(this.towerHP);
                document.getElementById('tower-hp-fill').style.width = (this.towerHP / 10) + "%";
                this.updateTowerVisual();
            }
            this.updateCycle(); this.player.update();
            for (let i = this.enemies.length - 1; i >= 0; i--) {
                const z = this.enemies[i]; z.update(this.player, this.allies, this.tower, this.walls);
                if (z.dead) { this.scene.remove(z.mesh); this.enemies.splice(i, 1); this.credits += 400; this.player.updateUI(); }
            }
            this.allies.forEach((a, i) => { a.update(this.enemies); if (a.dead) { this.scene.remove(a.mesh); this.allies.splice(i, 1); } });
            this.walls.forEach((w, i) => { if (w.hp <= 0) { this.scene.remove(w.mesh); this.walls.splice(i, 1); } });
            this.grenades.forEach((g, i) => { g.update(); if (g.exploded) { this.scene.remove(g.mesh); this.grenades.splice(i, 1); } });
            this.renderer.render(this.scene, this.camera);
        }
    }

    class Wall {
        constructor(game, pos) {
            this.game = game; this.hp = 500;
            const geo = new THREE.BoxGeometry(4, 3, 0.8);
            const mat = new THREE.MeshPhongMaterial({color: 0x444444});
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.copy(pos); this.game.scene.add(this.mesh);
        }
    }

    class Player {
        constructor(game) {
            this.game = game; this.hp = 100; this.grenades = 3; this.keys = {};
            this.camera = game.camera; this.camera.rotation.order = 'YXZ';
            this.velocityY = 0; this.isGrounded = true; this.height = 1.6;
            this.isDead = false; this.camera.position.set(20, this.height, 20); this.weapon = new Weapon(this);
            window.onkeydown = (e) => this.keys[e.code] = true;
            window.onkeyup = (e) => this.keys[e.code] = false;
            window.onmousemove = (e) => { if (!this.game.isPaused && !this.isDead) { this.camera.rotation.y -= e.movementX * 0.002; this.camera.rotation.x -= e.movementY * 0.002; this.camera.rotation.x = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, this.camera.rotation.x)); }};
            window.onmousedown = (e) => { if (!this.game.isPaused && !this.isDead) { if(e.button === 0) this.weapon.isFiring = true; if(e.button === 2) this.weapon.setADS(true); }};
            window.onmouseup = (e) => { if(e.button === 0) this.weapon.isFiring = false; if(e.button === 2) this.weapon.setADS(false); };
        }
        respawn() { this.hp = 100; this.isDead = false; this.camera.position.set(5, this.height, 5); document.getElementById('death-screen').style.display = 'none'; document.body.requestPointerLock(); this.updateUI(); }
        jump() { if (this.isGrounded && !this.isDead) { this.velocityY = 0.15; this.isGrounded = false; } }
        throwGrenade() { if (this.grenades > 0 && !this.isDead) { this.grenades--; this.game.grenades.push(new Grenade(this.game)); this.updateUI(); } }
        update() {
            if (this.isDead) return;
            const speed = 0.15; const dir = new THREE.Vector3();
            if (this.keys['KeyW']) dir.z -= 1; if (this.keys['KeyS']) dir.z += 1;
            if (this.keys['KeyA']) dir.x -= 1; if (this.keys['KeyD']) dir.x += 1;
            if (dir.length() > 0) {
                dir.normalize().applyQuaternion(this.camera.quaternion);
                let nextX = this.camera.position.x + dir.x * speed;
                let nextZ = this.camera.position.z + dir.z * speed;
                let canMove = true;
                for (let tree of this.game.treeObstacles) if (Math.sqrt(Math.pow(nextX-tree.x,2) + Math.pow(nextZ-tree.z,2)) < tree.radius) { canMove = false; break; }
                if (canMove) { this.camera.position.x = nextX; this.camera.position.z = nextZ; }
            }
            this.velocityY -= 0.008; this.camera.position.y += this.velocityY;
            if (this.camera.position.y <= this.height) { this.camera.position.y = this.height; this.velocityY = 0; this.isGrounded = true; }
            this.weapon.update();
        }
        takeDamage(amt) { if (this.isDead) return; this.hp -= amt; this.updateUI(); if (this.hp <= 0) { this.hp = 0; this.isDead = true; document.exitPointerLock(); document.getElementById('death-screen').style.display = 'flex'; this.updateUI(); } }
        updateUI() { document.getElementById('hp-val').innerText = Math.round(this.hp); document.getElementById('hp-fill').style.width = this.hp + "%"; document.getElementById('credits').innerText = this.game.credits; document.getElementById('grenade-count').innerText = this.grenades; document.getElementById('tower-hp-val').innerText = Math.round(this.game.towerHP); document.getElementById('tower-hp-fill').style.width = (this.game.towerHP / 10) + "%"; this.weapon.updateUI(); }
    }

    class Weapon {
        constructor(player) {
            this.player = player; this.damage = 35; this.fireRate = 400; this.lastFire = 0;
            this.ammo = 30; this.maxAmmo = 30; this.reserveAmmo = 120;
            this.isReloading = false; this.isADS = false; this.isFiring = false; this.type = 'pistol';
            this.muzzleFlash = null;
            this.createModel('pistol');
        }
        createModel(type) {
            if(this.mesh) this.player.camera.remove(this.mesh);
            this.mesh = new THREE.Group(); const mat = new THREE.MeshPhongMaterial({color: 0x111111});
            if (type === 'sniper' || type === 'auto_sniper') { // OTO SNIPER GÖRSELİ
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.8), mat);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.2), type === 'auto_sniper' ? new THREE.MeshPhongMaterial({color: 0x00ffff}) : mat); barrel.rotation.x = Math.PI/2; barrel.position.z = -0.7;
                const scope = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.3), new THREE.MeshPhongMaterial({color:0x333})); scope.rotation.x = Math.PI/2; scope.position.y = 0.12;
                this.mesh.add(body, barrel, scope);
            } else if (type === 'smg') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.6), mat);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.25), mat); barrel.rotation.x = Math.PI/2; barrel.position.z = -0.4;
                const grip = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.06), mat); grip.position.set(0, -0.15, -0.1);
                this.mesh.add(body, barrel, grip);
            } else if (type === 'shotgun') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.2, 0.6), mat);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.7), mat); barrel.rotation.x = Math.PI/2; barrel.position.z = -0.4;
                const pump = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.12, 0.3), new THREE.MeshPhongMaterial({color: 0x333333})); pump.position.set(0, -0.12, -0.2);
                const stock = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.3), mat); stock.position.z = 0.4;
                this.mesh.add(body, barrel, pump, stock);
            } else { this.mesh.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.4), mat)); }
            this.muzzleFlash = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshBasicMaterial({color: 0xffff00}));
            this.muzzleFlash.visible = false; this.muzzleFlash.position.z = -1.2;
            this.mesh.add(this.muzzleFlash);
            this.player.camera.add(this.mesh); this.mesh.position.set(0.4, -0.4, -0.8);
        }
        upgrade(type) {
            this.type = type;
            if (type === 'sniper') { this.damage = 350; this.fireRate = 1200; this.maxAmmo = 5; this.reserveAmmo = 25; document.getElementById('weapon-name').innerText = "AWM SNIPER"; }
            else if (type === 'auto_sniper') { // FINAL SNIPER DEĞERLERİ
                this.damage = 1000; // TEK ATISTA ÖLDÜRME
                this.fireRate = 250; // TARAMALI SNIPER
                this.maxAmmo = 20; // 20 MERMİ
                this.reserveAmmo = 80;
                document.getElementById('weapon-name').innerText = "GÖKTÜRK OTO-SNIPER";
            }
            else if (type === 'smg') { this.damage = 35; this.fireRate = 120; this.maxAmmo = 45; this.reserveAmmo = 180; document.getElementById('weapon-name').innerText = "KARAKURT SMG"; }
            else { this.damage = 150; this.fireRate = 850; this.maxAmmo = 8; this.reserveAmmo = 32; document.getElementById('weapon-name').innerText = "EJDER POMPALI"; }
            this.createModel(type); this.ammo = this.maxAmmo; this.updateUI();
        }
        setADS(val) { 
            this.isADS = val; 
            if (this.type === 'sniper' || this.type === 'auto_sniper') { // OTO SNIPER DURBUN DESTEGI
                this.player.camera.fov = val ? 10 : 75; 
                document.getElementById('sniper-scope').style.display = val ? 'block' : 'none'; 
                this.mesh.visible = !val; 
            }
            else { this.player.camera.fov = val ? 45 : 75; this.mesh.position.set(val?0:0.4, val?-0.2:-0.4, val?-0.5:-0.8); }
            this.player.camera.updateProjectionMatrix(); 
        }
        reload() {
            if (this.isReloading || this.ammo === this.maxAmmo || this.reserveAmmo <= 0) return;
            this.isReloading = true; document.getElementById('ammo-display').innerText = "DOLUYOR...";
            setTimeout(() => { let transfer = Math.min(this.maxAmmo - this.ammo, this.reserveAmmo); this.ammo += transfer; this.reserveAmmo -= transfer; this.isReloading = false; this.updateUI(); }, 1500);
        }
        update() { if (this.isFiring) this.shoot(); this.animateIdle(); }
        triggerFlash() { if(!this.muzzleFlash) return; this.muzzleFlash.visible = true; setTimeout(() => this.muzzleFlash.visible = false, 50); }
        shoot() {
            if (Date.now() - this.lastFire < this.fireRate || this.ammo <= 0 || this.isReloading) return;
            this.lastFire = Date.now(); this.ammo--; this.updateUI(); this.player.game.playSynthSound('shoot');
            this.triggerFlash();
            
            if (this.type === 'shotgun') {
                let hitCount = 0;
                this.player.game.enemies.forEach(z => {
                    const dist = z.mesh.position.distanceTo(this.player.camera.position);
                    if (dist < 40) { 
                        const dirToZombie = new THREE.Vector3().subVectors(z.mesh.position, this.player.camera.position).normalize();
                        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(this.player.camera.quaternion);
                        if (forward.angleTo(dirToZombie) < 0.6 && hitCount < 5) { z.takeDamage(this.damage); hitCount++; }
                    }
                });
            } else {
                const ray = new THREE.Raycaster(); 
                ray.setFromCamera(new THREE.Vector2(0,0), this.player.camera);
                const enemyMeshes = this.player.game.enemies.map(z => z.mesh);
                enemyMeshes.forEach(m => m.updateMatrixWorld()); 
                const hits = ray.intersectObjects(enemyMeshes, true); 
                
                if (hits.length > 0) {
                    for (let i = 0; i < hits.length; i++) {
                        let hitObj = hits[i].object;
                        while (hitObj.parent && !hitObj.userData.instance) { hitObj = hitObj.parent; }
                        const instance = hitObj.userData.instance;
                        if (instance && !instance.dead) { 
                            instance.takeDamage(this.damage);
                            break; 
                        }
                    }
                }
            }
        }
        updateUI() { if (!this.isReloading) document.getElementById('ammo-display').innerText = `${this.ammo} / ${this.reserveAmmo}`; }
        animateIdle() { if (!this.isADS) this.mesh.position.y = -0.4 + Math.sin(Date.now() * 0.005) * 0.01; }
    }

    class Turret {
        constructor(game, pos) {
            this.game = game; this.dead = false; this.lastFire = 0; this.hp = 100;
            this.mesh = new THREE.Group();
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.7,0.4), new THREE.MeshPhongMaterial({color:0x222}));
            const g = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.8), new THREE.MeshPhongMaterial({color:0xf00}));
            g.position.y = 0.3; this.mesh.add(b, g);
            
            this.flash = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xffff00}));
            this.flash.visible = false;
            this.flash.position.set(0, 0.3, -0.6);
            this.mesh.add(this.flash);

            this.mesh.position.copy(pos); this.game.scene.add(this.mesh);
        }
        update(enemies) { 
            if (enemies.length === 0) return;
            let nearest = null; let minDist = 100;
            enemies.forEach(e => { const d = e.mesh.position.distanceTo(this.mesh.position); if (d < minDist && !e.dead) { minDist = d; nearest = e; } });
            
            if (nearest) {
                this.mesh.lookAt(nearest.mesh.position.x, 0.5, nearest.mesh.position.z); 
                this.mesh.rotateY(Math.PI);

                if (Date.now() - this.lastFire > 400) { 
                    nearest.takeDamage(30); 
                    this.lastFire = Date.now(); 
                    this.flash.visible = true;
                    setTimeout(() => this.flash.visible = false, 50);
                }
            } 
        }
        takeDamage(amt) { this.hp -= amt; if(this.hp <= 0) this.dead = true; }
    }

    class AllySoldier {
        constructor(game, pos, weaponType) {
            this.game = game; this.dead = false; this.lastFire = 0;
            const configs = {
                pistol: {hp: 250, dmg: 40, rate: 1000, color: 0x2980b9, wName: 'pistol'},
                smg: {hp: 500, dmg: 30, rate: 200, color: 0x27ae60, wName: 'smg'},
                sniper: {hp: 350, dmg: 300, rate: 2000, color: 0x000000, wName: 'sniper'},
                shotgun: {hp: 800, dmg: 150, rate: 1500, color: 0xc0392b, wName: 'shotgun'}
            };
            const conf = configs[weaponType] || configs.pistol;
            this.hp = conf.hp; this.maxHP = conf.hp; this.damage = conf.dmg; this.fireRate = conf.rate;
            this.weaponType = conf.wName;
            this.mesh = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.3, 0.4), new THREE.MeshPhongMaterial({color: conf.color}));
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshPhongMaterial({color: 0xf39c12})); head.position.y = 0.85;
            this.weaponMesh = this.createWeaponModel(this.weaponType); this.weaponMesh.position.set(0.3, 0.3, -0.4);
            
            this.flash = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0xffaa00}));
            this.flash.visible = false; this.flash.position.z = -0.6; this.weaponMesh.add(this.flash);
            
            const barGeo = new THREE.BoxGeometry(0.8, 0.1, 0.1);
            this.hpBar = new THREE.Mesh(barGeo, new THREE.MeshBasicMaterial({color: 0x00ff00})); this.hpBar.position.y = 1.3;
            this.mesh.add(body, head, this.hpBar, this.weaponMesh); this.mesh.position.copy(pos); this.game.scene.add(this.mesh);
        }

        createWeaponModel(type) {
            const group = new THREE.Group(); const mat = new THREE.MeshPhongMaterial({color: 0x222});
            if(type === 'sniper') {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.8), mat));
                const b = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), mat); b.rotation.x = Math.PI/2; b.position.z = -0.6; group.add(b);
            } else if(type === 'smg') {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.5), mat));
                const g = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05), mat); g.position.set(0, -0.15, -0.1); group.add(g);
            } else if(type === 'shotgun') {
                group.add(new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.6), mat));
            } else { group.add(new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), mat)); }
            return group;
        }

        update(enemies) { 
            if (this.hp <= 0) { this.dead = true; return; } 
            this.hpBar.scale.x = Math.max(0, this.hp / this.maxHP); this.hpBar.quaternion.copy(this.game.camera.quaternion);
            
            this.game.allies.forEach(other => {
                if (other !== this) {
                    const dist = this.mesh.position.distanceTo(other.mesh.position);
                    if (dist < 1.5 && dist > 0.001) { 
                        const push = new THREE.Vector3().subVectors(this.mesh.position, other.mesh.position).normalize().multiplyScalar(0.05);
                        this.mesh.position.add(push);
                    }
                }
            });

            let nearest = null; let minDist = 100;
            enemies.forEach(e => { const d = e.mesh.position.distanceTo(this.mesh.position); if (d < minDist && !e.dead) { minDist = d; nearest = e; } });
            
            if (nearest) {
                this.mesh.lookAt(nearest.mesh.position.x, this.mesh.position.y, nearest.mesh.position.z); 
                this.mesh.rotateY(Math.PI);

                if (Date.now() - this.lastFire > this.fireRate) {
                    nearest.takeDamage(this.damage); 
                    this.lastFire = Date.now(); 
                    this.flash.visible = true; 
                    setTimeout(() => this.flash.visible = false, 50);
                }
            } else { 
                this.mesh.lookAt(this.game.player.camera.position.x, this.mesh.position.y, this.game.player.camera.position.z); 
                this.mesh.rotateY(Math.PI);
            }

            if (this.mesh.position.y < 5 && this.mesh.position.distanceTo(this.game.player.camera.position) > 7) { 
                const d = new THREE.Vector3().subVectors(this.game.player.camera.position, this.mesh.position).normalize(); 
                this.mesh.position.addScaledVector(d, 0.08); 
            } 
        }
        takeDamage(amt) { this.hp -= amt; if(this.hp <= 0) this.dead = true; }
    }

    class Zombie {
        constructor(game) {
            this.game = game; this.dead = false; this.hp = 100 + (game.wave * 25);
            this.lastAttackTime = 0; 
            this.mesh = new THREE.Group(); 
            this.mesh.userData.instance = this; 
            
            const mat = new THREE.MeshPhongMaterial({ color: 0x39ff14, emissive: 0x004400, emissiveIntensity: 0.5 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 0.5), mat);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mat); head.position.y = 1.0;
            this.mesh.add(body, head);
            
            body.userData.instance = this; head.userData.instance = this;

            let angle = Math.random() * Math.PI * 2;
            let jitterRadius = 85 + Math.random() * 15; 
            this.mesh.position.set(Math.cos(angle) * jitterRadius, 0.75, Math.sin(angle) * jitterRadius); 
            this.game.scene.add(this.mesh);
        }
        update(player, allies, tower, walls) { 
            if (this.dead || isNaN(this.mesh.position.x)) return;

            this.game.enemies.forEach(other => {
                if (other !== this && !other.dead) {
                    const pushDir = new THREE.Vector3().subVectors(this.mesh.position, other.mesh.position);
                    const pushDist = pushDir.length();
                    if (pushDist < 1.2) {
                        const pushAmt = 0.03;
                        if (pushDist < 0.001) {
                            this.mesh.position.x += (Math.random() - 0.5) * pushAmt;
                            this.mesh.position.z += (Math.random() - 0.5) * pushAmt;
                        } else {
                            pushDir.divideScalar(pushDist).multiplyScalar(pushAmt);
                            this.mesh.position.add(pushDir);
                        }
                    }
                }
            });

            let targets = [{ pos: tower.position.clone(), obj: 'tower' }, { pos: player.camera.position.clone(), obj: 'player' }];
            allies.forEach(a => targets.push({ pos: a.mesh.position.clone(), obj: 'ally', target: a }));
            walls.forEach(w => targets.push({ pos: w.mesh.position.clone(), obj: 'wall', target: w }));
            
            targets.forEach(t => { t.pos.y = 0; t.dist = this.mesh.position.distanceTo(t.pos); });
            targets.sort((a,b) => a.dist - b.dist); 
            let best = targets[0];
            
            let stop = (best.obj === 'tower') ? 6.0 : (best.obj === 'wall' ? 3.0 : 2.5);
            if (best.dist > stop) {
                const dir = new THREE.Vector3().subVectors(best.pos, this.mesh.position).normalize(); dir.y = 0;
                this.mesh.position.addScaledVector(dir, 0.06 + (this.game.wave * 0.003));
                this.mesh.lookAt(best.pos.x, 0.75, best.pos.z); 
            } else if (Date.now() - this.lastAttackTime > 1000) {
                this.lastAttackTime = Date.now();
                if(best.obj === 'tower') this.game.towerTakeDamage(10); 
                else if(best.obj === 'player') player.takeDamage(15);
                else if(best.obj === 'ally') best.target.takeDamage(20);
                else if(best.obj === 'wall') best.target.hp -= 50; 
            } 
        }
        takeDamage(amt) { 
            if(this.dead || isNaN(amt)) return; 
            this.hp -= amt; 
            if (this.hp <= 0 || isNaN(this.hp)) { this.hp = 0; this.dead = true; } 
        }
    }

    class Grenade {
        constructor(game) {
            this.game = game; this.exploded = false; this.timer = 2000;
            this.velocity = new THREE.Vector3(0, 0.2, -0.6).applyQuaternion(game.camera.quaternion);
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshPhongMaterial({ color: 0x000 }));
            this.mesh.position.copy(game.camera.position); this.game.scene.add(this.mesh);
        }
        update() { 
            this.velocity.y -= 0.01; this.mesh.position.add(this.velocity); 
            if (this.mesh.position.y < 0.2) { this.mesh.position.y = 0.2; this.velocity.set(0,0,0); } 
            this.timer -= 16; if (this.timer <= 0 && !this.exploded) this.explode(); 
        }
        explode() { 
            this.exploded = true; this.game.playSynthSound('explosion'); 
            this.game.enemies.forEach(z => { 
                if (!z.dead && z.mesh.position.distanceTo(this.mesh.position) < 20) { 
                    z.takeDamage(450); 
                }
            }); 
        }
    }

    window.game = new Game();
});
</script>
</body>
</html>